---
slug: angular
title: Best Practices trong Angular (kèm RxJS)
authors: [ducbq1]
tags: [angular, frontend]
---
# 📚 Best Practices trong Angular (kèm RxJS)

## 📁 1. Cấu trúc Dự Án Rõ Ràng

Chia theo module tính năng (feature-based).

```bash
/src/app/
  ├── auth/
  ├── dashboard/
  ├── shared/     # component, pipe dùng chung
  └── core/       # services singleton
```

## 🧩 2. Module Hóa Đúng Cách

- **SharedModule**: chứa component, pipe, directive dùng chung.
- **CoreModule**: chứa các singleton service như auth, logger,...
- **Lưu ý**: CoreModule chỉ import trong AppModule.

## ♻️ 3. Sử dụng RxJS Đúng Cách

### 🔁 Hủy Subscription khi không dùng nữa

```ts
private destroy$ = new Subject<void>();

ngOnDestroy() {
  this.destroy$.next();
  this.destroy$.complete();
}

this.service.getData()
  .pipe(takeUntil(this.destroy$))
  .subscribe(...);
```

### ✅ Dùng async pipe trong template

```html
<div *ngIf="data$ | async as data">{{ data }}</div>
```

## 🚨 4. Xử Lý Lỗi RxJS (Error Handling)

```ts
this.api.getData().pipe(
  catchError((err) => {
    this.logger.error(err);
    return of([]); // fallback
  })
);
```

- Sử dụng **HttpInterceptor** để xử lý lỗi tập trung (toàn cục).

## 🧠 5. Smart Component vs Dumb Component

| Loại Component | Chức Năng                          |
| -------------- | ---------------------------------- |
| Smart          | Gọi API, xử lý logic, state        |
| Dumb           | Hiển thị, nhận @Input(), @Output() |

## 💬 6. Dịch Vụ (Services) Phân Tầng

- Logic gọi API, state... nên để trong service.
- Component chỉ dùng để giao tiếp với UI.

## 🔒 7. Bảo Mật

- Không lưu thông tin nhạy cảm vào `localStorage` hoặc `sessionStorage`.
- Sử dụng **CanActivate**, **CanLoad** để bảo vệ route.

## 🔁 8. DRY & Reusability

- Tạo directive, pipe, và component nhỏ để tái sử dụng.
- Hạn chế lặp lại code trong template.

## 🚀 9. Tối Ưu Hiệu Năng

```ts
@Component({
  changeDetection: ChangeDetectionStrategy.OnPush
})
```

- Tránh dùng `.map()`, `.filter()` trong template.

## 🧪 10. Testing

- **Unit Test**: Component, Service, Pipe...
- **E2E Test**: Cypress, Playwright (hoặc Protractor nếu cũ)

---

# 📦 RxJS Operators Tổng Hợp

## ✅ Tạo Observable

| Tên            | Mô tả                           |
| -------------- | ------------------------------- |
| `of()`         | Tạo observable từ giá trị       |
| `from()`       | Tạo từ Promise, Iterable,...    |
| `interval()`   | Tạo timer phát giá trị liên tục |
| `timer()`      | Phát giá trị sau delay          |
| `throwError()` | Tạo observable lỗi              |
| `EMPTY`        | Tạo observable rỗng             |

## 🔁 Biến đổi dữ liệu

| Tên            | Mô tả                                    |
| -------------- | ---------------------------------------- |
| `map()`        | Biến đổi giá trị đầu ra                  |
| `pluck()`      | Lấy thuộc tính con từ object             |
| `scan()`       | Tương tự reduce (có lưu state)           |
| `buffer()`     | Gom các giá trị thành mảng               |
| `concatMap()`  | Lần lượt gọi observable tuần tự          |
| `switchMap()`  | Hủy observable cũ, dùng cái mới          |
| `mergeMap()`   | Gọi song song nhiều observable           |
| `exhaustMap()` | Bỏ qua nếu observable cũ chưa hoàn thành |

## ✅ Lọc giá trị

| Tên                      | Mô tả                                   |
| ------------------------ | --------------------------------------- |
| `filter()`               | Lọc theo điều kiện                      |
| `distinctUntilChanged()` | Chỉ phát khi giá trị thay đổi           |
| `take()`                 | Lấy N giá trị đầu tiên                  |
| `takeUntil()`            | Hủy khi observable khác phát giá trị    |
| `first()`, `last()`      | Lấy giá trị đầu/cuối                    |
| `debounceTime()`         | Trì hoãn xử lý (thường dùng với search) |
| `throttleTime()`         | Giới hạn tốc độ phát giá trị            |
| `skip()`                 | Bỏ qua N giá trị đầu tiên               |

## ⚙️ Kết hợp nhiều Observable

| Tên                | Mô tả                                         |
| ------------------ | --------------------------------------------- |
| `combineLatest()`  | Kết hợp giá trị cuối cùng từ nhiều observable |
| `forkJoin()`       | Đợi tất cả complete và trả về kết quả         |
| `withLatestFrom()` | Gộp observable chính với observable phụ       |
| `zip()`            | Ghép theo thứ tự từ nhiều observable          |

## 🚨 Xử lý lỗi

| Tên            | Mô tả                                    |
| -------------- | ---------------------------------------- |
| `catchError()` | Bắt lỗi và thay thế bằng observable khác |
| `retry()`      | Thử lại N lần nếu lỗi                    |
| `retryWhen()`  | Tùy biến logic retry nâng cao            |

## 🔄 Khác

| Tên             | Mô tả                             |
| --------------- | --------------------------------- |
| `tap()`         | Side effect (log, debug...)       |
| `finalize()`    | Gọi khi observable complete/error |
| `delay()`       | Trì hoãn phát giá trị             |
| `shareReplay()` | Chia sẻ observable đã phát        |

# 🧩 Component Best Practices với RxJS trong Angular

```ts
import { Component, OnInit, OnDestroy } from "@angular/core";
import { Subject, Observable, of } from "rxjs";
import {
  catchError,
  takeUntil,
  tap,
  switchMap,
  filter,
  map,
  shareReplay,
} from "rxjs/operators";
import { MyService } from "./my.service";
import { MyData } from "./my-data.interface";

@Component({
  selector: "app-my-component",
  templateUrl: "./my-component.component.html",
  styleUrls: ["./my-component.component.scss"],
})
export class MyComponent implements OnInit, OnDestroy {
  data$!: Observable<MyData[]>;

  private destroy$ = new Subject<void>();

  constructor(private myService: MyService) {}

  ngOnInit(): void {
    this.data$ = this.myService.getData().pipe(
      filter((data) => !!data),
      map((data) =>
        data.map((item) => ({ ...item, name: item.name.toUpperCase() }))
      ),
      tap(() => console.log("Fetched data")),
      catchError((error) => {
        console.error("Error fetching data", error);
        return of([]);
      }),
      shareReplay(1),
      takeUntil(this.destroy$)
    );

    // example if you need to subscribe manually:
    // this.data$.subscribe(data => {
    //   // do something with data
    // });
  }

  ngOnDestroy(): void {
    this.destroy$.next();
    this.destroy$.complete();
  }
}
```

---

## 📌 Các RxJS Operators Đã Dùng

| RxJS Operator | Mục đích                                                                             |
| ------------- | ------------------------------------------------------------------------------------ |
| `takeUntil`   | Hủy observable khi component bị destroy để tránh memory leak                         |
| `catchError`  | Bắt lỗi và trả fallback observable (`of([])`)                                        |
| `tap`         | Thực hiện side-effect như log dữ liệu                                                |
| `switchMap`   | Chuyển đổi từ observable này sang observable khác, thường dùng khi gọi API phụ thuộc |
| `filter`      | Lọc giá trị không mong muốn                                                          |
| `map`         | Biến đổi dữ liệu                                                                     |
| `shareReplay` | Chia sẻ observable để tránh gọi lại API khi có nhiều subscriber                      |

---

## 🧩 Interface nên dùng

```ts
export interface MyData {
  id: number;
  name: string;
  // các thuộc tính khác
}
```
