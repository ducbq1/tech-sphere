---
slug: abac
title: Kiểm Soát Truy Cập Dựa Trên Thuộc Tính Đơn Giản Với Spring Security
authors: [ducbq1]
tags: [abac, java, spring]
---
# Kiểm Soát Truy Cập Dựa Trên Thuộc Tính Đơn Giản Với Spring Security

## Giới Thiệu

Bạn đã từng làm việc trên phần mềm mà các quy tắc truy cập không chỉ dựa trên vai trò của người dùng mà còn dựa trên thực thể cụ thể mà vai trò đó được cấp quyền chưa?
Ví dụ như "Quản lý dự án có thể thêm người dùng vào **DỰ ÁN CỦA HỌ**", "Nhân viên cửa hàng có thể truy cập thông tin **CỬA HÀNG CỦA HỌ**", hoặc "Chủ sở hữu tài liệu có thể chỉnh sửa **TÀI LIỆU CỦA HỌ**"?

Hoặc, nơi các quy tắc truy cập dựa trên ngữ cảnh, như thời gian, mạng người dùng, hoặc kênh truy cập (như trang web, ứng dụng di động, hệ thống nội bộ, v.v.).
Ví dụ, "Tài nguyên này chỉ có thể được truy cập **TRONG GIỜ HÀNH CHÍNH** hoặc **CHỈ TỪ MẠNG NỘI BỘ**"?

Tất cả những điều đó, và vẫn cần logic của các quy tắc truy cập này có thể cấu hình và linh hoạt để được sửa đổi với ít (hoặc không) mã hóa phần mềm hoặc triển khai mới.

Nếu vậy, bạn có thể thấy **Kiểm Soát Truy Cập Dựa Trên Thuộc Tính (Attribute-Based Access Control - ABAC)** rất hữu ích.

---

## ABAC là gì?

Mọi yêu cầu truy cập sẽ có bốn yếu tố (chủ thể, tài nguyên, hành động và môi trường), trong đó:

- **Chủ thể**: thực thể (thường là người dùng) yêu cầu truy cập.
- **Tài nguyên**: đối tượng mà chủ thể muốn truy cập.
- **Hành động**: thao tác mà chủ thể muốn thực hiện trên tài nguyên.
- **Môi trường**: bối cảnh của yêu cầu truy cập (thời gian, vị trí, phương thức truy cập, v.v.).

**ABAC** cho phép hoặc từ chối truy cập dựa trên các thuộc tính của các yếu tố này.

Ví dụ, một quy tắc có thể là:

> "Cho phép truy cập nếu vai trò của người dùng là 'Quản lý dự án' và ID dự án trong yêu cầu khớp với ID dự án mà người dùng quản lý".

---

## Spring Security và SpEL

Spring Security cho phép các nhà phát triển tiêm logic kiểm soát truy cập của họ vào một thành phần tập trung và được thực thi (sử dụng kiểm soát truy cập dựa trên biểu thức) tại nhiều điểm thực thi khác nhau của ứng dụng, như trước/sau các cuộc gọi REST API và phương thức. Nó cung cấp tất cả ngữ cảnh cần thiết (tham số phương thức hoặc đối tượng trả về) để áp dụng logic kiểm soát truy cập.

SpEL (Spring Expression Language) là một ngôn ngữ biểu thức tương tự như Java EL, và được sử dụng trong Spring Security để định nghĩa các biểu thức truy cập.

## Thành Phần Chính

Phương pháp được trình bày trong bài viết này dựa trên các ý tưởng sau:

* Sử dụng các biểu thức Spring EL kiểu boolean để định nghĩa các quy tắc truy cập (ví dụ: `subject.project.id == resource.project.id`), các biểu thức này sẽ được lưu trữ trong một kho trung tâm (ví dụ: bộ nhớ, cơ sở dữ liệu, LDAP, tệp).
* Định nghĩa một thành phần tập trung có nhiệm vụ tải các quy tắc, bao bọc các yếu tố trong ngữ cảnh truy cập, và đánh giá các biểu thức quy tắc để quyết định xem truy cập có được cho phép hay không.
* Sử dụng các annotation của Spring như `@PostAuthorize` / `@PreAuthorize("hasPermission(...)")` (cùng với các thành phần khác được đề cập sau) để thực thi các quy tắc truy cập.

### Các thành phần chính trong phương pháp này bao gồm:

---

### `PermissionEvaluator`

Đây là điểm đầu vào để thực thi logic ABAC. Như đã đề cập trước đó, tất cả các quyết định truy cập được thực hiện bởi Spring Security (theo mô hình kiểm soát truy cập dựa trên biểu thức) đều được ủy quyền cho thành phần này. Tức là, tất cả các annotation như `@PreAuthorize("hasPermission(...)")`, `@PostAuthorize("hasPermission(...)")` sẽ được chuyển đến thành phần này để xử lý.

Phương pháp được trình bày ở đây tạo ra một lớp triển khai tùy chỉnh của thành phần `PermissionEvaluator`, lớp này đơn giản chỉ ủy quyền việc đưa ra quyết định truy cập cho thành phần `PolicyEnforcement`.

```java
public class AbacPermissionEvaluator implements PermissionEvaluator {
    @Autowired
    PolicyEnforcement policy;

    @Override
    public boolean hasPermission(Authentication authentication , Object targetDomainObject, Object permission) {
        //Getting subject
        Object user = authentication.getPrincipal();

        //Getting environment
        Map<String, Object> environment = new HashMap<>();
        environment.put("time", new Date());

        return policy.check(user, targetDomainObject, permission, environment);
    }

    @Override
    public boolean hasPermission(Authentication authentication, Serializable targetId, String targetType, Object permission) {
        return false;
    }
}
```

### `ContextAwarePolicyEnforcement`

Đây là một thành phần tùy chọn, tương tự như `PermissionEvaluator`, nhưng có thể được gọi tại  **bất kỳ đâu trong mã nguồn** , miễn là `SecurityContext` đã được khởi tạo và chứa thông tin xác thực của người dùng hiện tại.

Thành phần này được sử dụng trong những trường hợp mà **dữ liệu cần thiết để đưa ra quyết định truy cập không sẵn có** cho các annotation `@PreAuthorize` và `@PostAuthorize`.

Ví dụ, trong trường hợp cập nhật một thực thể:

* `@PreAuthorize` chỉ có thể truy cập vào  **các tham số truyền vào phương thức** , tức là dữ liệu của thực thể sau khi cập nhật, trong khi quyết định truy cập lại **phụ thuộc vào dữ liệu của thực thể hiện có** trong hệ thống.
* `@PostAuthorize` sẽ được gọi  **sau khi quá trình cập nhật hoàn tất** , điều này là  **quá muộn để thực hiện kiểm tra quyền truy cập** .

```java
public class ContextAwarePolicyEnforcement {
    @Autowired
    protected PolicyEnforcement policy;

    public void checkPermission(Object resource, String permission) {
        //Getting the subject
        Authentication auth = SecurityContextHolder.getContext().getAuthentication();

        //Getting the environment
        Map<String, Object> environment = new HashMap<>();
        environment.put("time", new Date());

        if(!policy.check(auth.getPrincipal(), resource, permission, environment))
        throw new AccessDeniedException("Access is denied");
    }
}
```

### `PolicyEnforcement`

Đây là nơi  **quyết định truy cập thực sự được đưa ra** . Cơ chế hoạt động như sau:

1. **Tải tất cả các `PolicyRule`** thông qua `PolicyDefinition`.
2. **Lọc các `PolicyRule`** để chỉ giữ lại những quy tắc **có thể áp dụng** (tức là các quy tắc mà biểu thức `target` được đánh giá là `true`) trong ngữ cảnh truy cập hiện tại.
3. **Đánh giá tất cả các `PolicyRule` áp dụng được** (tức là đánh giá biểu thức điều kiện) trong ngữ cảnh truy cập hiện tại. Nếu  **bất kỳ biểu thức nào trả về `true`** , quyền truy cập sẽ được cấp;  **ngược lại** , truy cập sẽ bị từ chối.

> Lý do mà chúng ta **không hiện thực logic này trực tiếp trong `PermissionEvaluator`** là để  **tách biệt logic ABAC khỏi Spring Security** , và cho phép việc đưa ra quyết định có thể được gọi **ngoài phạm vi Spring Security Framework** (ví dụ: bằng cách gọi trực tiếp `PolicyEnforcement` trong bất kỳ logic nào của phương thức).

```java
public class BasicPolicyEnforcement implements PolicyEnforcement {
    @Autowired
    private PolicyDefinition policyDefinition;

    @Override
    public boolean check(Object subject, Object resource, Object action, Object environment) {
        //Get all policy rules
        List<PolicyRule> allRules = policyDefinition.getAllPolicyRules();

        //Wrap the context
        SecurityAccessContext cxt = new SecurityAccessContext(subject, resource, action, environment);

        //Filter the rules according to context.
        List<PolicyRule> matchedRules = filterRules(allRules, cxt);

        //finally, check if any of the rules are satisfied, otherwise return false.
        return checkRules(matchedRules, cxt);
    }

    private List<PolicyRule> filterRules(List<PolicyRule> allRules, SecurityAccessContext cxt) {
        List<PolicyRule> matchedRules = new ArrayList<>();
        for(PolicyRule rule : allRules) {
            try {
                if(rule.getTarget().getValue(cxt, Boolean.class)) {
                    matchedRules.add(rule);
                }
            } catch(EvaluationException ex) {
                logger.error("An error occurred while evaluating PolicyRule.", ex);
            }
        }
        return matchedRules;
    }

    private boolean checkRules(List<PolicyRule> matchedRules, SecurityAccessContext cxt) {
        for(PolicyRule rule : matchedRules) {
            try {
                if(rule.getCondition().getValue(cxt, Boolean.class)) {
                    return true;
                }
            } catch(EvaluationException ex) {
                logger.error("An error occurred while evaluating PolicyRule.", ex);
            }
        }
        return false;
    }
}
```

---

### `PolicyDefinition`

Đây là  **interface đại diện cho kho lưu trữ `PolicyRule`** . Nó chỉ có một phương thức duy nhất là `getAllPolicyRules`, dùng để tải tất cả các quy tắc truy cập hiện có.

Interface này giúp **ẩn đi chi tiết về cách lưu trữ các quy tắc truy cập** đối với các client sử dụng policy. Thành phần này có thể được hiện thực cho (nhưng không giới hạn ở): policy lưu trong bộ nhớ (`in-memory`), file JSON, hoặc cơ sở dữ liệu. Cách thức lưu trữ cụ thể sẽ do bên triển khai thành phần này quyết định.

---

### `PolicyRule`

Đây là **thành phần nguyên tử (atomic)** của một chính sách truy cập – nơi **định nghĩa logic ABAC** sẽ được đánh giá khi cần thiết.

`PolicyRule` có các thuộc tính chính sau:

* `target`: Một biểu thức boolean sử dụng SpEL (Spring Expression Language) xác định khi nào quy tắc này **có hiệu lực** (nếu biểu thức đánh giá là `true`, thì quy tắc sẽ được áp dụng).
* `condition`: Một biểu thức boolean SpEL xác định khi nào quy tắc này **được thoả mãn** (nếu biểu thức đánh giá là `true`, thì truy cập sẽ được cho phép).

Cả hai biểu thức trên đều **có quyền truy cập đến bốn thành phần** trong yêu cầu truy cập: `subject` (đối tượng), `resource` (tài nguyên), `action` (hành động), và `environment` (môi trường).

> Để đơn giản hóa, các `Rule` mặc định chỉ có **tác dụng tích cực** (tức là cho phép truy cập nếu được thỏa mãn), nhưng chúng có thể được mở rộng dễ dàng để có **tác dụng tiêu cực** (tức là từ chối truy cập nếu được thỏa mãn).

---

### `SecurityAccessContext`

Đây là một **lớp wrapper** chứa tất cả các thành phần của một yêu cầu truy cập. Nó có các thuộc tính tương ứng với từng thành phần: `Subject`, `Resource`, `Action`, và `Environment`.

Đối với mỗi quyết định truy cập cần thực hiện, một **instance** của lớp này sẽ được tạo bởi `PolicyEnforcement` và được **gán các giá trị tương ứng** với yêu cầu truy cập hiện tại.

Các instance này sẽ đóng vai trò là **đối tượng gốc (Root Object)** để đánh giá các biểu thức trong `PolicyRule`.
